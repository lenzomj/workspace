#!/usr/bin/env python2
#vi: set ft=python

from __future__ import print_function

import argparse
import os.path
import sys
import shlex
import subprocess
import urlparse
import hashlib

def open_configuration(filename):
    path = os.path.expandvars("${HOME}/.workspace.conf")
    config = { }
    if os.path.exists(path):
        with open(path) as f:
            line = f.readline()
            while line:
                line = line.strip()
                hashed = hashlib.md5(line)
                config[hashed.hexdigest()] = line
                line = f.readline()
    return config

def handle_within(key, args):
    cmd =[]
    if key == 'within':
        cmd.append("pushd '{0}' >/dev/null;".format(args))
    elif key == 'end_within':
        cmd.append("popd &> /dev/null;")
    return cmd

def handle_with(key, args):
    cmd=[]
    if key == 'with':
        cmd.append("cat >> '{0}' <<'_EOS'".format(args))
    elif key == 'end_with':
        cmd.append("_EOS")
    return cmd

def handle_puts(key, args):
    return [args]

def handle_config(key, args):
    cmd=[]
    hashed = hashlib.md5(args)
    config = open_configuration(".workspace.conf")
    if hashed.hexdigest() not in config.keys():
        cmd.append("echo '{0}' >> ${{HOME}}/.workspace.conf".format(args))
    return cmd

def handle_git(key, args):
    cmd = """
    if [[ ! -d "{local}" ]]; then
      echo "Mirroring {remote} ..." >&2
      git clone --mirror "{remote}" "{local}"
    else
      pushd "{local}" &> /dev/null;
        echo "Updating {local} ..." >&2
        git remote update
      popd &> /dev/null;
    fi
    """
    local = ""
    remote = ""
    if key == 'github':
        remote = "https://github.com/{0}".format(args)
        local = args
    else:
        url = urlparse.urlsplit(args)
        remote = args
        local = url.path.lstrip('/')
    return [cmd.format(local=local, remote=remote)]

def handle_get(key, args):
    cmd = """
    echo "Downloading {remote} ..." >&2
    curl -# -L "{remote}" -o "{local}"
    """
    url = urlparse.urlsplit(args)
    remote = url.geturl()
    local = os.path.basename(url.path)
    return [cmd.format(local=local, remote=remote)]

def handle_rsync(key, args):
    cmd = """
    echo "Syncing {remote} ..." >&2
    rsync -avSHP --delete {flags} {remote} {local} >&2
    """
    args = args.split()
    url = urlparse.urlsplit(args.pop()) # URI is always last
    remote = url.geturl()
    local = url.path.lstrip('/')
    flags = ' '.join(args)
    return [cmd.format(local=local, remote=remote, flags=flags)]

def translate(directive):
    handlers = { 'within'     : handle_within,
                 '!config'     : handle_config,
                 'end_within' : handle_within,
                 'with'       : handle_with,
                 'end_with'   : handle_with,
                 '!puts'   : handle_puts,
                 'github' : handle_git,
                 'git'    : handle_git,
                 'get'    : handle_get,
                 'rsync'  : handle_rsync }

    key = directive[0].lower()
    args = directive[1]
    return handlers[key](key, args)

def read_manifest(filestream):
    script = []
    lex = shlex.shlex(filestream, posix=True)
    lex.whitespace_split = True
    for token in lex:
        if not token.startswith('!'):
            token = os.path.expandvars(token)
        directive = token.split(':', 1)
        if len(directive) == 1:
            directive.append(None)
        script.extend(translate(directive))
    return script

def execute(script):
    print(script)
    p = subprocess.Popen(script,
                         executable='/bin/bash',
                         shell=True,
                         stderr=subprocess.PIPE,
                         stdout=None)

    for stderr_line in iter(p.stderr.readline, ""):
        yield stderr_line
    p.stderr.close()
    rc = p.wait()
    if rc:
        raise subprocess.CalledProcessError(rc, script)

def open_manifests(filenames):
    manifest_dir = os.path.dirname(os.path.realpath(__file__))
    manifest_dir = os.path.join(manifest_dir, 'manifest')
    for filename in filenames:
        manifest_path = os.path.join(manifest_dir, filename)
        if not os.path.exists(manifest_path):
            sys.stderr.write("Error: {0} does not exist\n".format(filename))
        else:
            with open(manifest_path) as f:
                script = '\n'.join(read_manifest(f))
                for output in execute(script):
                    print(output, end="")

def prompt():
    parser = argparse.ArgumentParser(description="J.A.R.V.I.S")
    parser.add_argument('--update',
                        nargs='*', metavar='manifest', help='Update manifests')
    args = parser.parse_args()
    if args.update is not None and len(args.update) > 0:
        open_manifests(args.update)
    else:
        parser.print_help()

if __name__ == "__main__":
    prompt()
